# plan-and-persist.sh
#!/usr/bin/env bash
# Purpose: One-stop script to (A) spawn a planning-only hive-mind for any $OBJECTIVE and
#          (B) optionally persist roadmap SAVE BLOCKS to files â€” in a separate action.
# Design goals:
# - Keep planning and writing strictly separated (no writes during planning unless ACTION=persist).
# - Be generic (any $OBJECTIVE), phase-aware, and optionally Serena-aware for onboarding/stack docs planning.
# - Emit save-ready blocks during planning; parse & write them during persistence safely.
# - Avoid external deps beyond bash coreutils, awk, sed, and npx (for claude-flow spawn).
# - Adds phase-aware actions that compose with wtctl.sh: phase-start | phase-persist | phase-finish.


# # Plan only (no writes). Choose SAVE_STYLE=index or multi.
# OBJECTIVE="Baseline the repo; derive stack docs " PHASE="SPEC"  QUALITY_LEVEL=thorough PROFILE=auto PROJECT_KIND=auto STACK_HINTS="" SAVE_STYLE=index USE_SERENA=1 ROADMAP_PATH="ROADMAP.md" bash plan-and-persist.sh ACTION=plan+persist

# # 1) Plan (no writes)
# OBJECTIVE="Add OAuth login (PKCE) to Service X" PHASE="SPEC" bash plan-and-persist.sh

# # 2) Persist from a saved output file
# OBJECTIVE="Add OAuth login (PKCE) to Service X" ACTION=persist ROADMAP_SRC=roadmap/plan-output.txt bash plan-and-persist.sh

# # 3) Dry-run what would be written
# OBJECTIVE="Add OAuth login (PKCE) to Service X" ACTION=check ROADMAP_SRC=roadmap/plan-output.txt bash plan-and-persist.sh

# # 4) Plan now, then immediately persist (keeps phases explicit)
# OBJECTIVE="Stack docs for all projects" PHASE="SPEC" SAVE_STYLE=multi ACTION=plan+persist bash plan-and-persist.sh > /dev/null


help() {
  echo "[INFO] Usage: OBJECTIVE=<OBJECTIVE> ACTION=plan|persist|check|plan+persist [ENV VARS...] bash plan-and-persist.sh" >&2
  echo "[INFO] Example: OBJECTIVE='Add OAuth login (PKCE) to Service X' ACTION=plan+persist bash plan-and-persist.sh" >&2
  echo "[INFO] Example: OBJECTIVE='Stack docs for all projects' PHASE=
SPEC SAVE_STYLE=multi ACTION=plan+persist bash plan-and-persist.sh" >&2
  echo "[INFO] Example: OBJECTIVE='Add OAuth login (PKCE) to Service X' ACTION=persist ROADMAP_SRC=roadmap/plan-output.txt bash plan-and-persist.sh" >&2
  echo "[INFO] Example: OBJECTIVE='Add OAuth login (PKCE) to Service X' ACTION=check ROADMAP_SRC=roadmap/plan-output.txt bash plan-and-persist.sh" >&2
  echo "[INFO] Example: OBJECTIVE='Stack docs for all projects' PHASE=SPEC SAVE_STYLE=multi ACTION=plan+persist bash plan-and-persist.sh > /dev/null" >&2
  echo "" >&2
  echo "[INFO] Available environment variables:" >&2
  echo "[INFO] Use OBJECTIVE: The planning objective (required)." >&2
  echo "[INFO] Use ACTION: The action to perform (plan, persist, check, plan+persist)." >&2
  echo "[INFO] Available actions:" >&2
  echo "  - plan: Generate a planning prompt and run the hive-mind." >&2
  echo "  - persist: Write the planning output to files." >&2
  echo "  - check: Dry-run the persistence without writing files." >&2
  echo "  - plan+persist: Plan and then persist the output." >&2
  echo "  - plan | persist | check | plan+persist" >&2
  echo "[INFO] Set PHASE to specify the planning phase (AUTO|SPEC|DESIGN|IMPL|REVIEW)." >&2
  echo "[INFO] Set AGENTS to specify the maximum of agents to use (default: 8)." >&2
  echo "[INFO] Set GIT_HISTORY to specify how many git commits to consider (default: 20)." >&2
  echo "[INFO] Set SAVE_STYLE to index or multi (default: index)." >&2
  echo "[INFO] Set USE_SERENA to 1 to include Serena onboarding playbook in the prompt (default: 1)." >&2
  echo "[INFO] Set SERENA_PROJECT to specify the project name/path for serena.activate_project (default: empty)." >&2
  echo "[INFO] Set SERENA_REQUIRED to 1 to warn if Serena is expected (default: 1)." >&2
  echo "[INFO] Set MEM_NAMESPACE to override the memory namespace (default: autogenerated)." >&2
  echo "[INFO] Set ROADMAP_PATH to specify where to save the roadmap (default: roadmap/PLAN_<PHASE>_<DATE_STR>_<OBJ_SLUG>.md)." >&2
  echo "[INFO] Set INDEX_SAVE_PATH to specify where to save the index (default: roadmap/STACKDOCS_PLAN_<REPO_SLUG>_<DATE_STR>.md)." >&2
  echo "[INFO] Set PROFILE to specify the planning profile (default: auto)." >&2
  echo "[INFO] Set PROJECT_KIND to specify the project kind (default: auto)." >&2
  echo "[INFO] Set STACK_HINTS to specify stack hints (default: empty)." >&2
  echo "[INFO] Set ROADMAP_SCHEMA to specify the roadmap schema version (default: v1)." >&2
  echo "[INFO] Set ROADMAP_SRC to read from a file, or leave empty to read from stdin." >&2
}

set -euo pipefail

### ===== CLI / ENV =====
ACTION="${ACTION:-plan}"            # plan | persist | check | plan+persist
PHASE="${PHASE:-AUTO}"              # AUTO|SPEC|DESIGN|IMPL|REVIEW
AGENTS="${AGENTS:-8}"
GIT_HISTORY="${GIT_HISTORY:-20}"
SAVE_STYLE="${SAVE_STYLE:-index}"   # index | multi
USE_SERENA="${USE_SERENA:-1}"       # 1 => include Serena onboarding playbook in prompt (planning only)
SERENA_PROJECT="${SERENA_PROJECT:-}" # optional project name/path for serena.activate_project
SERENA_REQUIRED="${SERENA_REQUIRED:-1}" # 1 => warn loudly if Serena is expected
MEM_NAMESPACE="${MEM_NAMESPACE:-}"  # override memory namespace; else autogenerated
DATE_STR="$(date +%F)"
BASE_BRANCH="${BASE_BRANCH:-main}"

if [[ -z "${OBJECTIVE}" ]]; then
  help
  exit 1
fi

# Persistence-related
ROADMAP_SRC="${ROADMAP_SRC:-}"      # path to file with SAVE BLOCKS (or empty to read stdin)
DRY_RUN="${DRY_RUN:-0}"             # with ACTION=check or persist: 1 => don't write, only show intent

### ===== Helpers =====
slug() { printf '%s' "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[[:space:][:punct:]]+/-/g; s/^-+|-+$//g'; }
OBJ_SLUG="$(slug "${OBJECTIVE}")"
REPO_SLUG="$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g')"
SUFFIX="${TRACK:+-${TRACK}}"

# default save targets for planning
: "${ROADMAP_PATH:=roadmap/PLAN_${PHASE}_${DATE_STR}_${OBJ_SLUG}.md}"
: "${INDEX_SAVE_PATH:=roadmap/STACKDOCS_PLAN_${REPO_SLUG}_${DATE_STR}.md}"

# memory namespace
if [[ -z "${MEM_NAMESPACE}" ]]; then
  MEM_NAMESPACE="plan-${REPO_SLUG}-${PHASE}-${OBJ_SLUG}${SUFFIX}"
  MEM_NAMESPACE="$(printf '%s' "${MEM_NAMESPACE}" | tr -cd '[:alnum:]_.-')"
fi

: "${PROFILE:=auto}"           # auto|service-backend|service-fullstack|app-frontend|library-js|library-py|data-ml|infra
: "${PROJECT_KIND:=auto}"      # auto|monorepo|service|library|tooling|infra|data
: "${STACK_HINTS:=}"           # CSV hints, bias only
: "${ROADMAP_SCHEMA:=v1}"      # roadmap schema version
: "${SECTIONS:=}"              # CSV allow-list; empty => profile defaults
: "${LOCALE:=en}"
: "${QUALITY_LEVEL:=balanced}" # brief|balanced|thorough
: "${TITLE_OVERRIDE:=}"
: "${TAGS:=}"                  # CSV

# [ADD: helper to render CSV in prompt-friendly form]
csv_or_empty() { [[ -n "$1" ]] && printf '%s' "$1" | sed 's/,/, /g' || printf 'none'; }

# [ADD: profile defaults block]
profile_defaults() {
  case "${PROFILE}" in
    service-backend)
      echo "sections: Objectives,Task DAG,Design(API/DB/Migrations/Observability),Test Strategy,Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: backend"
      ;;
    service-fullstack)
      echo "sections: Objectives,Task DAG,Design(API/DB + Frontend Routing/State),Test Strategy (UI+API),Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: frontend, backend"
      ;;
    app-frontend)
      echo "sections: Objectives,Task DAG,Design(Routing/State/Bundling/A11y),Test Strategy(UI/E2E),Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: frontend"
      ;;
    library-js|library-py)
      echo "sections: Objectives,Task DAG,Design(API & Public Surface),Test Strategy(Matrix/Coverage),Tooling & Enforcement(Release/Semver),Risks,Gates,Open Questions"
      echo "stacks: library"
      ;;
    data-ml)
      echo "sections: Objectives,Task DAG,Design(Pipelines/Data Contracts/Repro/Eval),Test Strategy(Data/Model),Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: data"
      ;;
    infra)
      echo "sections: Objectives,Task DAG,Design(Topology/IaC/Secrets/Rollout),Test Strategy(Env/Smoke),Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: infra"
      ;;
    auto|*)
      echo "sections: (auto)"
      echo "stacks: (auto)"
      ;;
  esac
}

### ===== Build spawn prompt (planning only) =====
build_prompt() {
  local prompt guards guards_coding context phaserules serena subagents concurrency enforce deliverables saveindex savemulti compliance

  read -r -d '' guards <<'EOF'
SYSTEM / GUARDED MODE:
- ULTRATHINKING: You are a planning agent, not a coding agent.
- You are the Queen coordinator of a multi-agent hive-mind.
- **No coding, no file writes, no shell commands** beyond read/search/list. (EXCEPTION: plans, task DAGs, and roadmaps).
- If any worker proposes code or edits, STOP and redirect to planning artifacts (checklists, DAGs, doc outlines).
- Before launching any worker, ensure the worker type is appropriate for the task (e.g., Code_Reviewer, Design_Architect) and exists in the agent list.
EOF

  if [[ "${PHASE}" = "DO_IMPL" ]]; then
    read -r -d '' guards_coding <<'EOF'
**CODING SESSION ONLY**
EOF
  else
    read -r -d '' guards_coding <<'EOF'
**PLANNING SESSION ONLY**
EOF
  fi

  read -r -d '' context <<EOF
INPUTS & CONTEXT:
- Read ./CLAUDE.md; summarize relevant parts for Phase <<<PHASE>>>.
- If present, read code_style_conventions.md,codebase_structure.md,project_purpose.md,suggested_commands.md,task_completion_workflow.md,tech_stack.md in .serena/memory/. If not present, ask serena to generate them.
- If present, read ./ROADMAP.md and summarize related goals.
- Skim the last ~<<<GIT_HISTORY>>> commits (diff or summary) to detect changes that impact the objective.
- If any roadmap/PLAN_REVIEW_<DATE_STR>_<OBJ_SLUG>.md exists, read it and summarize the last review and its findings. You must not repeat the same mistakes.
  - In the end of the phase, if the review improvements are implemented, you can move the roadmap/PLAN_REVIEW_<DATE_STR>_<OBJ_SLUG>.md file to roadmap/PLAN_REVIEW_<DATE_STR>_<OBJ_SLUG>_DONE.md.

OBJECTIVE:
${OBJECTIVE}

PHASE:
${PHASE}
EOF

  if [[ "${PHASE}" = "SPEC" ]]; then
    read -r -d '' phaserules <<EOF
<!> Produce a precise, testable specification (acceptance criteria, NFRs, constraints, edge cases).
EOF
  elif [[ "${PHASE}" = "DESIGN" ]]; then
    read -r -d '' phaserules <<EOF

<!> Read on roadmap/PLAN_SPEC_<DATE_STR>_<OBJ_SLUG>.md, produce pseudocode/architecture (modules, interfaces, data/dataflow), reference existing code to MAXIMIZE REUSE and simplificity.
EOF
  elif [[ "${PHASE}" = "IMPL" ]]; then
    read -r -d '' phaserules <<EOF

<!> Read on roadmap/PLAN_SPEC_<DATE_STR>_<OBJ_SLUG>.md and roadmap/PLAN_DESIGN_<DATE_STR>_<OBJ_SLUG>.md, Produce a TDD-first plan (tests-first), migration steps, and risk/rollback plan. (only PLAN, no code changes).
EOF
  elif [[ "${PHASE}" = "DO_IMPL" ]]; then
    read -r -d '' phaserules <<EOF
<!>  Read on roadmap/PLAN_SPEC_<DATE_STR>_<OBJ_SLUG>.md and roadmap/PLAN_DESIGN_<DATE_STR>_<OBJ_SLUG>.md and roadmap/PLAN_IMPL_<DATE_STR>_<OBJ_SLUG>.md, IMPLEMENT the roadmap/ in code, write tests, and ensure code quality (linting, type-checking, security checks).
EOF
  elif [[ "${PHASE}" = "REVIEW" ]]; then
    read -r -d '' phaserules <<EOF
<!> Read on roadmap/PLAN_SPEC_<DATE_STR>_<OBJ_SLUG>.md and roadmap/PLAN_DESIGN_<DATE_STR>_<OBJ_SLUG>.md and roadmap/PLAN_IMPL_<DATE_STR>_<OBJ_SLUG>.md and previous modified files in the commit, plan verification: coverage, static/security analysis, performance checks, doc updates, release notes.
EOF
  else
  read -r -d '' phaserules <<'EOF'
- AUTO  : infer appropriate planning depth from CLAUDE.md/ROADMAP.md and propose phase gates.
EOF
  fi

  read -r -d '' serena <<EOF
SERENA MCP (IF AVAILABLE) â€“ ONBOARDING PLAYBOOK:
- For the current repo or project path:
  1) serena.activate_project(project = "${SERENA_PROJECT:-<repo-root-or-name>}")
  2) serena.initial_instructions()
  3) serena.check_onboarding_performed()
     - if false: run serena.onboarding() ONCE and follow returned instructions.
- Gate: Do not proceed to stack profiling until onboarding is done.

MULTI-PROJECT & STACK DETECTION (READ-ONLY):
- Enumerate sub-projects via conventions/config (apps/*, packages/*, services/*, src/*, pyproject.toml, package.json, go.mod, pom.xml, Cargo.toml).
- Use Serena listing & symbol/language queries to detect languages, frameworks, build/test tools per sub-project.
- Infer stacks per sub-project: Frontend / Backend / Infra / Data / Mobile (as applicable).
- For big projects, make sure to think before any tooling decisions since the number of tokens is limited.

CONCURRENCY & SYNTHESIS:
- Run Stack_Profiler agents CONCURRENTLY (read-only) per sub-project/stack.
- Merge into a single Overview per project; QA_Reviewer checks completeness & consistency.
EOF

  read -r -d '' subagents <<EOF
SUB-AGENTS (define roles & least-privilege scopes):
- Global objective: "${OBJECTIVE}"
- Sub-objectives: <<<SUB_OBJECTIVE>>>
- Requirements_Analyst, Codebase_Analyst, Security_Analyst, Performance_Analyst,
  Tooling_Planner (pre-commit/VS Code/MCP), QA_Reviewer (gatekeeper), Integration_Planner.
- Add/remove roles as needed, justify with scope and success metrics.
- After each action, share the results with the team.
- Read: .serena/memory/(code_style_conventions.md,codebase_structure.md,project_purpose.md,suggested_commands.md,task_completion_workflow.md,tech_stack.md)
  - if not present, ask serena to generate them.
- READ: CLAUDE.md, ROADMAP.md
- Always think before an action is taken.
EOF

  read -r -d '' enforce <<'EOF'
ENFORCEMENT BLUEPRINTS:
- Pre-commit usage: hooks (format, lint, type, security, secrets), failure policies, cross-project rollout plan.
- VS Code diagnostics: required extensions, .vscode/settings/tasks, problem matchers; how to make the Problems panel authoritative.
- MCP & Agents hygiene: plan idempotent updates for MCP server lists and .claude/agents/ generation based on latest commits.
EOF

  if [[ "${PHASE}" = "DO_IMPL" ]]; then
    read -r -d '' concurrency <<'EOF'
- <!> implement the inputed roadmap/ plan in code, write tests, and ensure code quality (linting, type-checking, security checks).
EOF
  else
    read -r -d '' concurrency <<'EOF'
- <!> run the sub-agents concurrently to produce the planning artifacts.
EOF
  fi


  if [[ "${SAVE_STYLE}" = "index" ]]; then
    read -r -d '' deliverables <<'EOF'
DELIVERABLES:
1) State Snapshot (from CLAUDE.md/ROADMAP.md).
2) Create TODO list from IMPLE roadmap, then for any inputed Task DAG tables: TaskID, Summary, OwnerAgent, Inputs, Outputs, Phase, Parallelizable?, Exit Criteria.
  - If received PHASE=SPEC: Update the Task DAG table with current advancements
  - If received PHASE=DESIGN: Update the Task DAG table with design overview and modules/interfaces advancements.
  - If received PHASE=IMPL: Update the Task DAG table with    TDD-first plan, test cases, and migration steps advancements.
  - If received PHASE=REVIEW: Update the Task DAG table with verification plan (coverage, static/security analysis, performance checks, doc updates) advancements.
3) RACI per sub-agent & Success Metrics per deliverable.
4) Risk Register with mitigations (alpha/flag instability, tooling drift, monorepo variance).
5) Exit/Gate Criteria to advance phase (artifacts + approvals).
6) Clarifying Questions (â‰¤5), then a consolidated plan.
EOF
  else
  read -r -d '' deliverables <<'EOF'
DELIVERABLES:
1) State Snapshot (from CLAUDE.md/ROADMAP.md).
2*) For any outputed Task DAG table: TaskID, Summary, OwnerAgent, Inputs, Outputs, Phase, Parallelizable?, Exit Criteria.
  - If PHASE=SPEC: produce a detailed task breakdown with acceptance criteria.
  - If PHASE=DESIGN: produce a design overview with modules/interfaces.
  - If PHASE=IMPL: produce a TDD-first plan with test cases and migration steps.
  - If PHASE=REVIEW: produce a verification plan (coverage, static/security analysis, performance checks, doc updates).
2**) For any inputed Task DAG tables: TaskID, Summary, OwnerAgent, Inputs, Outputs, Phase, Parallelizable?, Exit Criteria.
  - If received PHASE=SPEC: Update the Task DAG table with current advancements
  - If received PHASE=DESIGN: Update the Task DAG table with design overview and modules/interfaces advancements.
  - If received PHASE=IMPL: Update the Task DAG table with TDD-first plan, test cases, and migration steps advancements.
  - If received PHASE=REVIEW: Update the Task DAG table with verification plan (coverage, static/security analysis, performance checks, doc updates) advancements.
3) RACI per sub-agent & Success Metrics per deliverable.
4) Risk Register with mitigations (alpha/flag instability, tooling drift, monorepo variance).
5) Exit/Gate Criteria to advance phase (artifacts + approvals).
6) Clarifying Questions (â‰¤5), then a consolidated plan.
EOF
  fi

  read -r -d '' saveindex <<'EOF'
FINAL SAVE BLOCK (INDEX MODE):
- Conclude with:
  ```
  [[SAVE-AT]]: <<<ROADMAP_PATH>>>
  ---8<--- ROADMAP MARKDOWN START
  # Plan â€“ <<<PHASE>>> â€“ <<<DATE_STR>>>
  (complete, ready-to-save roadmap in Markdown; include state snapshot, DAG, RACI, risks, gates)
  ---8<--- ROADMAP MARKDOWN END
  ```
EOF

  read -r -d '' savemulti <<'EOF'
FINAL SAVE BLOCKS (MULTI-FILE MODE):
- First, output an index block:
  ```
  [[SAVE-AT]]: <<<INDEX_SAVE_PATH>>>
  ---8<--- ROADMAP MARKDOWN START
  # Plan â€“ Index â€“ <<<PHASE>>> â€“ <<<DATE_STR>>>
  (state snapshot, project matrix if stacks are profiled, global risks, gates)
  ---8<--- ROADMAP MARKDOWN END
  ```
- Then, for each planned artifact, output one or more write blocks (examples):
  ```
  [[WRITE-FILE]]: docs/stack/<project>/overview.md
  ---8<--- START
  # <Project> â€“ Overview
  ...
  ---8<--- END

  [[WRITE-FILE]]: docs/stack/<project>/<stack>.md
  ---8<--- START
  # <Project> â€“ <Stack> Tech Stack
  ...
  ---8<--- END
  ```
EOF

  read -r -d '' compliance <<'EOF'
COMPLIANCE:
- Future coder agents MUST satisfy linters/type-checkers **without simplifying functionality**; placeholders forbidden.
- Maximize reuse of existing code in later phases; reference modules/classes/functions explicitly.
EOF
  if [[ "$PHASE" = "DO_IMPL" ]]; then
    read -r -d '' compliance <<EOF
HARD STOP:
  <!> Confirm all files are modified as expected, and the implementation plan is complete.
  <!> Ensure pre-commit hooks are satisfied (linting, type-checking, security checks).
      - If there are not -> Fix them before proceeding. You MUST NOT SIMPLIFY FUNCTIONALITY.
  <!> If any files are modified, ensure the implementation plan is complete and ready for review.
  <!> Ensure the main entry point (e.g., index.js, main.py) is updated with the new functionality.
  <!> Ensure the main entry point can be run without errors and produces the expected output.
  <!> Ensure NO unused/temporary code in the new files is left in the codebase. (script, styles, docs, etc.)
EOF
  else
    read -r -d '' compliance <<EOF
HARD STOP:
  <!> Confirm that no files were modified and only planning text was produced.
EOF
  fi

  read -r -d '' BLOCK_PROFILE <<EOF
PROFILE & PROJECT TYPE:
- PROFILE: ${PROFILE}
- PROJECT_KIND: ${PROJECT_KIND}
- STACK_HINTS: $(csv_or_empty "${STACK_HINTS}")
- QUALITY_LEVEL: ${QUALITY_LEVEL}
- LOCALE: ${LOCALE}
- If PROFILE=auto or PROJECT_KIND=auto, infer using Serena (if available) and heuristics (package.json, pyproject.toml, go.mod, pom.xml, Cargo.toml, docker/helm/terraform).
- Use hints only as bias; do not contradict symbol evidence.
EOF

  if [[ "${PHASE}" = "DO_IMPL" ]]; then
    read -r -d '' BLOCK_SCHEMA <<EOF
ROADMAP SCHEMA: ${ROADMAP_SCHEMA}
- Analyse the implementation details roadmap/, then spawn adapted agents to implement the plan. Make sure to follow the TDD-first approach.
- Update the roadmap checklist with the implementation details.
- Title: ${TITLE_OVERRIDE:-<auto>}
- Required base sections (Schema v1):
  1) State Snapshot  2) Objectives & Acceptance  3) Task DAG
  4) Design/Constraints (profile-adaptive)  5) Test Strategy implementation
  6) Coding & Enforcement  7) Risks & Mitigations 8) CLEAN (ensure no unused/temporary code is left)
  9) Gate/Exit Criteria  10) Open Questions (â‰¤5)
EOF
  else
    read -r -d '' BLOCK_SCHEMA <<EOF
ROADMAP SCHEMA: ${ROADMAP_SCHEMA}
- Emit a YAML front-matter with: id (stable slug), objective, phase, profile, project_kind, inferred_stacks, tags, schema, generated_at (ISO), locale.
- Title: ${TITLE_OVERRIDE:-<auto>}
- Required base sections (Schema v1):
  1) State Snapshot  2) Objectives & Acceptance  3) Task DAG
  4) Design/Constraints (profile-adaptive)  5) Test Strategy
  6) Tooling & Enforcement  7) Risks & Mitigations
  8) Gate/Exit Criteria  9) Open Questions (â‰¤5)
- Sections to include (allow-list if provided): $(csv_or_empty "${SECTIONS}")
EOF
  fi

  read -r -d '' BLOCK_ADAPTIVITY <<EOF
ADAPTIVITY:
- If PROFILE=auto, propose the best-fit profile and **explain why** (symbols/paths).
- If PROJECT_KIND=auto, classify: monorepo/service/library/tooling/infra/data.
- List detected stacks per project (frontend/backend/infra/data/mobile/library) and cite evidence.
- When conflicting signals exist, prefer Serena symbol evidence over heuristics; ask up to 3 clarifying questions.
EOF

  # Assemble
  prompt="${guards}
${guards_coding}
${context}
${phaserules}
"

# Add standardized, adaptive controls (profile, schema, adaptivity)
  prompt+="${BLOCK_PROFILE}
${BLOCK_SCHEMA}
${BLOCK_ADAPTIVITY}
"

  if [[ "${USE_SERENA}" = "1" ]]; then
    prompt+="${serena}
"
  fi
  prompt+="${subagents}
${concurrency}
${enforce}
${deliverables}
"

  if [[ "${SAVE_STYLE}" = "multi" ]]; then
    prompt+="${savemulti}
"
  else
    prompt+="${saveindex}
"
  fi

  prompt+="${compliance}
"

  # Inject vars
  prompt="${prompt//<<<OBJECTIVE>>>/${OBJECTIVE}}"
  prompt="${prompt//<<<PHASE>>>/${PHASE}}"
  prompt="${prompt//<<<GIT_HISTORY>>>/${GIT_HISTORY}}"
  prompt="${prompt//<<<ROADMAP_PATH>>>/${ROADMAP_PATH}}"
  prompt="${prompt//<<<INDEX_SAVE_PATH>>>/${INDEX_SAVE_PATH}}"
  prompt="${prompt//<<<DATE_STR>>>/${DATE_STR}}"

  printf '%s' "$prompt"
}

### ===== Queen flag autodetect (alpha robust) =====
detect_queen_flag() {
  local flag=""
  if npx claude-flow@alpha hive-mind spawn --help 2>/dev/null | grep -qi -- '--queen-type'; then
    if npx claude-flow@alpha hive-mind spawn --help 2>/dev/null | grep -qi 'adaptive'; then
      flag="--queen-type adaptive"
    elif npx claude-flow@alpha hive-mind spawn --help 2>/dev/null | grep -qi 'strategic'; then
      flag="--queen-type strategic"
    fi
  fi
  printf '%s' "$flag"
}

### ===== Planning action =====
do_plan() {
  echo "[INFO] Planning phase: ${PHASE} for objective: ${OBJECTIVE}" >&2
  echo "[INFO] Using ${AGENTS} agents, git history depth: ${GIT_HISTORY}, save style: ${SAVE_STYLE}" >&2
  echo "[INFO] Memory namespace: ${MEM_NAMESPACE}" >&2
  echo "[INFO] Roadmap path: ${ROADMAP_PATH}" >&2
  echo "[INFO] Index save path: ${INDEX_SAVE_PATH}" >&2
  echo "[INFO] Profile: ${PROFILE}, Project kind: ${PROJECT_KIND}, Stack hints: ${STACK_HINTS}" >&2
  echo "[INFO] Quality level: ${QUALITY_LEVEL}, Locale: ${LOCALE}" >&2
  echo "[INFO] Roadmap schema: ${ROADMAP_SCHEMA}" >&2
  echo "[INFO] Tags: ${TAGS}" >&2
  echo "[INFO] Dry run: ${DRY_RUN}" >&2

  if [[ "${USE_SERENA}" = "1" && "${SERENA_REQUIRED}" = "1" ]]; then
    echo "[WARN] USE_SERENA=1 & SERENA_REQUIRED=1: ensure Serena MCP is configured in Claude Code for this project." >&2
  fi

  local prompt queen_flag
  prompt="$(build_prompt)"
  queen_flag="$(detect_queen_flag)"
  echo "[INFO] Command is: npx claude-flow@alpha hive-mind spawn ${prompt} ${queen_flag} --claude --max-workers ${AGENTS} --verbose --auto-scale --auto-spawn --memory-size 5000 --memory-namespace ${MEM_NAMESPACE}" >&2
  npx claude-flow@alpha hive-mind spawn \
    "${prompt}" \
    --claude --max-workers "${AGENTS}" --verbose --auto-scale --auto-spawn --memory-size 5000 \
    --memory-namespace "${MEM_NAMESPACE}" \
    ${queen_flag}
}

### ===== Persistence utilities =====
extract_save_at() {
  grep -Eo '^\[\[SAVE-AT\]\]:[[:space:]]+.*$' | sed -E 's/^\[\[SAVE-AT\]\]:[[:space:]]+//'
}
extract_index_body() {
  awk '/---8<--- ROADMAP MARKDOWN START/{flag=1; next} /---8<--- ROADMAP MARKDOWN END/{flag=0} flag'
}
iterate_write_blocks() {
  # Emits NUL-separated pairs: path \0 content \0 ...
  awk '
    /^\[\[WRITE-FILE\]\]:/ { file=$0; sub(/^\[\[WRITE-FILE\]\]:[[:space:]]+/,"",file); inblock=0; next }
    /---8<--- START/ { inblock=1; content=""; next }
    /---8<--- END/ {
      if (file != "") {
        printf "%s\0%s\0", file, content
        file=""; content="";
      }
      inblock=0; next
    }
    { if (inblock==1) content = content $0 "\n" }
  '
}

write_index_block() {
  local save_at="$1"; shift
  local body="$1"; shift
  if [[ -z "${save_at}" ]]; then
    echo "[INFO] No [[SAVE-AT]] index block detected." >&2
    return 0
  fi
  mkdir -p "$(dirname "${save_at}")"
  if [[ "${DRY_RUN}" = "1" ]]; then
    printf 'DRY-RUN: would write INDEX â†’ %s (bytes=%d)\n' "${save_at}" "$(printf '%s' "${body}" | wc -c)"
  else
    printf '%s' "${body}" > "${save_at}"
    printf 'WROTE INDEX: %s\n' "${save_at}"
  fi
}

write_file_blocks() {
  local tmp="$1"
  # Read NUL-separated pairs from iterate_write_blocks
  python3 - "$tmp" "$DRY_RUN" <<'PY'
import os, sys
path = sys.argv[1]
dry = sys.argv[2] == "1"
data = sys.stdin.buffer.read().decode('utf-8', 'replace')
parts = [p for p in data.split("\0") if p != ""]
for i in range(0, len(parts), 2):
    target = parts[i].strip()
    content = parts[i+1]
    os.makedirs(os.path.dirname(target) or ".", exist_ok=True)
    if dry:
        print(f"DRY-RUN: would write FILE â†’ {target} (bytes={len(content.encode())})")
    else:
        with open(target, "w", encoding="utf-8") as f:
            f.write(content)
        print(f"WROTE FILE: {target}")
PY
}

### ===== Persist/check action =====
do_persist_or_check() {
  local src="${ROADMAP_SRC:-}"
  local plan_dir="/plan_dir/_plan_blocks.$$"

  # Get input into temp file (from file or stdin)
  if [[ -n "${src}" ]]; then
    cat "${src}" > "${plan_dir}"
  else
    cat - > "${plan_dir}"
  fi

  # INDEX block
  local save_at body
  save_at="$(extract_save_at < "${plan_dir}" | head -n1 || true)"
  body="$(extract_index_body < "${plan_dir}" || true)"
  write_index_block "${save_at}" "${body}"

  # [[WRITE-FILE]] blocks
  iterate_write_blocks < "${plan_dir}" | write_file_blocks "${plan_dir}"

  rm -f "${plan_dir}"
}

### ===== Main =====
case "${ACTION}" in
  plan)
    do_plan
    ;;
  persist|check)
    [[ "${ACTION}" = "check" ]] && DRY_RUN="1"
    do_persist_or_check
    ;;
  plan+persist)
    # Plan to temp file then persist it (keeps separation explicit).
    plan_dir="plan_dir/_plan_output.$$"
    # shellcheck disable=SC2094
    { do_plan; } | tee "${plan_dir}"
    ROADMAP_SRC="${plan_dir}" ACTION="persist" DRY_RUN="${DRY_RUN}" "$0"
    ;;
  *)
    echo "[INFO] Unknown ACTION=${ACTION}." >&2
    help
    exit 2
    ;;
esac
