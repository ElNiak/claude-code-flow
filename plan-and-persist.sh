# plan-and-persist.sh
#!/usr/bin/env bash
# Purpose: One-stop script to (A) spawn a planning-only hive-mind for any $OBJECTIVE and
#          (B) optionally persist roadmap SAVE BLOCKS to files — in a separate action.
# Design goals:
# - Keep planning and writing strictly separated (no writes during planning unless ACTION=persist).
# - Be generic (any $OBJECTIVE), phase-aware, and optionally Serena-aware for onboarding/stack docs planning.
# - Emit save-ready blocks during planning; parse & write them during persistence safely.
# - Avoid external deps beyond bash coreutils, awk, sed, and npx (for claude-flow spawn).
# - Adds phase-aware actions that compose with wtctl.sh: phase-start | phase-persist | phase-finish.


# # Plan only (no writes). Choose SAVE_STYLE=index or multi.
# OBJECTIVE="Baseline the repo; derive stack docs " PHASE="SPEC"  QUALITY_LEVEL=thorough PROFILE=auto PROJECT_KIND=auto STACK_HINTS="" SAVE_STYLE=index USE_SERENA=1 ROADMAP_PATH="ROADMAP.md" bash plan-and-persist.sh ACTION=plan+persist

# # 1) Plan (no writes)
# OBJECTIVE="Add OAuth login (PKCE) to Service X" PHASE="SPEC" bash plan-and-persist.sh

# # 2) Persist from a saved output file
# OBJECTIVE="Add OAuth login (PKCE) to Service X" ACTION=persist ROADMAP_SRC=roadmap/plan-output.txt bash plan-and-persist.sh

# # 3) Dry-run what would be written
# OBJECTIVE="Add OAuth login (PKCE) to Service X" ACTION=check ROADMAP_SRC=roadmap/plan-output.txt bash plan-and-persist.sh

# # 4) Plan now, then immediately persist (keeps phases explicit)
# OBJECTIVE="Stack docs for all projects" PHASE="SPEC" SAVE_STYLE=multi ACTION=plan+persist bash plan-and-persist.sh > /dev/null

set -euo pipefail

### ===== CLI / ENV =====
ACTION="${ACTION:-plan}"            # plan | persist | check | plan+persist
: "${OBJECTIVE:?Set OBJECTIVE, e.g., OBJECTIVE='Add OAuth login (PKCE) to Service X'}"
PHASE="${PHASE:-AUTO}"              # AUTO|SPEC|DESIGN|IMPL|REVIEW
AGENTS="${AGENTS:-8}"
GIT_HISTORY="${GIT_HISTORY:-20}"
SAVE_STYLE="${SAVE_STYLE:-index}"   # index | multi
USE_SERENA="${USE_SERENA:-1}"       # 1 => include Serena onboarding playbook in prompt (planning only)
SERENA_PROJECT="${SERENA_PROJECT:-}" # optional project name/path for serena.activate_project
SERENA_REQUIRED="${SERENA_REQUIRED:-1}" # 1 => warn loudly if Serena is expected
MEM_NAMESPACE="${MEM_NAMESPACE:-}"  # override memory namespace; else autogenerated
DATE_STR="$(date +%F)"
BASE_BRANCH="${BASE_BRANCH:-main}"

# Persistence-related
ROADMAP_SRC="${ROADMAP_SRC:-}"      # path to file with SAVE BLOCKS (or empty to read stdin)
DRY_RUN="${DRY_RUN:-0}"             # with ACTION=check or persist: 1 => don't write, only show intent

### ===== Helpers =====
slug() { printf '%s' "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[[:space:][:punct:]]+/-/g; s/^-+|-+$//g'; }
OBJ_SLUG="$(slug "${OBJECTIVE}")"
REPO_SLUG="$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g')"
SUFFIX="${TRACK:+-${TRACK}}"

# default save targets for planning
: "${ROADMAP_PATH:=coordination/PLAN_${PHASE}_${DATE_STR}_${OBJ_SLUG}.md}"
: "${INDEX_SAVE_PATH:=coordination/STACKDOCS_PLAN_${REPO_SLUG}_${DATE_STR}.md}"

# memory namespace
if [[ -z "${MEM_NAMESPACE}" ]]; then
  MEM_NAMESPACE="plan-${REPO_SLUG}-${PHASE}-${OBJ_SLUG}${SUFFIX}"
  MEM_NAMESPACE="$(printf '%s' "${MEM_NAMESPACE}" | tr -cd '[:alnum:]_.-')"
fi

: "${PROFILE:=auto}"           # auto|service-backend|service-fullstack|app-frontend|library-js|library-py|data-ml|infra
: "${PROJECT_KIND:=auto}"      # auto|monorepo|service|library|tooling|infra|data
: "${STACK_HINTS:=}"           # CSV hints, bias only
: "${ROADMAP_SCHEMA:=v1}"      # roadmap schema version
: "${SECTIONS:=}"              # CSV allow-list; empty => profile defaults
: "${LOCALE:=en}"
: "${QUALITY_LEVEL:=balanced}" # brief|balanced|thorough
: "${TITLE_OVERRIDE:=}"
: "${TAGS:=}"                  # CSV

# [ADD: helper to render CSV in prompt-friendly form]
csv_or_empty() { [[ -n "$1" ]] && printf '%s' "$1" | sed 's/,/, /g' || printf 'none'; }

# [ADD: profile defaults block]
profile_defaults() {
  case "${PROFILE}" in
    service-backend)
      echo "sections: Objectives,Task DAG,Design(API/DB/Migrations/Observability),Test Strategy,Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: backend"
      ;;
    service-fullstack)
      echo "sections: Objectives,Task DAG,Design(API/DB + Frontend Routing/State),Test Strategy (UI+API),Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: frontend, backend"
      ;;
    app-frontend)
      echo "sections: Objectives,Task DAG,Design(Routing/State/Bundling/A11y),Test Strategy(UI/E2E),Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: frontend"
      ;;
    library-js|library-py)
      echo "sections: Objectives,Task DAG,Design(API & Public Surface),Test Strategy(Matrix/Coverage),Tooling & Enforcement(Release/Semver),Risks,Gates,Open Questions"
      echo "stacks: library"
      ;;
    data-ml)
      echo "sections: Objectives,Task DAG,Design(Pipelines/Data Contracts/Repro/Eval),Test Strategy(Data/Model),Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: data"
      ;;
    infra)
      echo "sections: Objectives,Task DAG,Design(Topology/IaC/Secrets/Rollout),Test Strategy(Env/Smoke),Tooling & Enforcement,Risks,Gates,Open Questions"
      echo "stacks: infra"
      ;;
    auto|*)
      echo "sections: (auto)"
      echo "stacks: (auto)"
      ;;
  esac
}

### ===== Build spawn prompt (planning only) =====
build_prompt() {
  local prompt guards context phaserules serena subagents concurrency enforce deliverables saveindex savemulti compliance

  read -r -d '' guards <<'EOF'
SYSTEM / GUARDED MODE:
- You are the Queen coordinator of a multi-agent hive-mind. **PLANNING-ONLY SESSION**.
- **No coding, no file writes, no shell commands** beyond read/search/list.
- If any worker proposes code or edits, STOP and redirect to planning artifacts (checklists, DAGs, doc outlines).
EOF

  read -r -d '' context <<EOF
INPUTS & CONTEXT:
- Read ./CLAUDE.md; summarize relevant parts for Phase <<<PHASE>>>.
- If present, read code_style_conventions.md,codebase_structure.md,project_purpose.md,suggested_commands.md,task_completion_workflow.md,tech_stack.md in .serena/memory/. If not present, ask serena to generate them.
- If present, read ./ROADMAP.md and summarize related goals.
- Skim the last ~<<<GIT_HISTORY>>> commits (diff or summary) to detect changes that impact the objective.

OBJECTIVE:
<<<OBJECTIVE>>>

PHASE:
<<<PHASE>>>
EOF

  read -r -d '' phaserules <<'EOF'
PHASE ADAPTATION:
- AUTO  : infer appropriate planning depth from CLAUDE.md/ROADMAP.md and propose phase gates.
- SPEC  : produce a precise, testable specification (acceptance criteria, NFRs, constraints, edge cases).
- DESIGN: produce pseudocode/architecture (modules, interfaces, data/dataflow), reference existing code to MAXIMIZE REUSE.
- IMPL  : DO NOT CODE. Produce a TDD-first plan (tests-first), migration steps, and risk/rollback plan.
- REVIEW: plan verification: coverage, static/security analysis, performance checks, doc updates, release notes.
EOF

  read -r -d '' serena <<EOF
SERENA MCP (IF AVAILABLE) – ONBOARDING PLAYBOOK:
- For the current repo or project path:
  1) serena.activate_project(project = "${SERENA_PROJECT:-<repo-root-or-name>}")
  2) serena.initial_instructions()
  3) serena.check_onboarding_performed()
     - if false: run serena.onboarding() ONCE and follow returned instructions.
- Gate: Do not proceed to stack profiling until onboarding is done.

MULTI-PROJECT & STACK DETECTION (READ-ONLY):
- Enumerate sub-projects via conventions/config (apps/*, packages/*, services/*, src/*, pyproject.toml, package.json, go.mod, pom.xml, Cargo.toml).
- Use Serena listing & symbol/language queries to detect languages, frameworks, build/test tools per sub-project.
- Infer stacks per sub-project: Frontend / Backend / Infra / Data / Mobile (as applicable).

CONCURRENCY & SYNTHESIS:
- Run Stack_Profiler agents CONCURRENTLY (read-only) per sub-project/stack.
- Merge into a single Overview per project; QA_Reviewer checks completeness & consistency.
EOF

  read -r -d '' subagents <<'EOF'
SUB-AGENTS (define roles & least-privilege scopes):
- Requirements_Analyst, Codebase_Analyst, Security_Analyst, Performance_Analyst,
  Tooling_Planner (pre-commit/VS Code/MCP), QA_Reviewer (gatekeeper), Integration_Planner.
- Add/remove roles as needed, justify with scope and success metrics.
- Read: .serena/memory/(code_style_conventions.md,codebase_structure.md,project_purpose.md,suggested_commands.md,task_completion_workflow.md,tech_stack.md) and CLAUDE.md, ROADMAP.md
EOF

  read -r -d '' enforce <<'EOF'
ENFORCEMENT BLUEPRINTS (PLAN-ONLY):
- Pre-commit usage: hooks (format, lint, type, security, secrets), failure policies, cross-project rollout plan.
- VS Code diagnostics: required extensions, .vscode/settings/tasks, problem matchers; how to make the Problems panel authoritative.
- MCP & Agents hygiene: plan idempotent updates for MCP server lists and .claude/agents/ generation based on latest commits.
- No file changes now—produce plans & checklists only.
EOF

  read -r -d '' deliverables <<'EOF'
DELIVERABLES (TEXT ONLY; DO NOT WRITE FILES):
1) State Snapshot (from CLAUDE.md/ROADMAP.md).
2) Task DAG table: TaskID, Summary, OwnerAgent, Inputs, Outputs, Phase, Parallelizable?, Exit Criteria.
3) RACI per sub-agent & Success Metrics per deliverable.
4) Risk Register with mitigations (alpha/flag instability, tooling drift, monorepo variance).
5) Exit/Gate Criteria to advance phase (artifacts + approvals).
6) Clarifying Questions (≤5), then a consolidated plan.
EOF

  read -r -d '' saveindex <<'EOF'
FINAL SAVE BLOCK (INDEX MODE):
- Conclude with:
  ```
  [[SAVE-AT]]: <<<ROADMAP_PATH>>>
  ---8<--- ROADMAP MARKDOWN START
  # Plan – <<<PHASE>>> – <<<DATE_STR>>>
  (complete, ready-to-save roadmap in Markdown; include state snapshot, DAG, RACI, risks, gates)
  ---8<--- ROADMAP MARKDOWN END
  ```
- Do NOT write files; emit the block only.
EOF

  read -r -d '' savemulti <<'EOF'
FINAL SAVE BLOCKS (MULTI-FILE MODE):
- First, output an index block:
  ```
  [[SAVE-AT]]: <<<INDEX_SAVE_PATH>>>
  ---8<--- ROADMAP MARKDOWN START
  # Plan – Index – <<<PHASE>>> – <<<DATE_STR>>>
  (state snapshot, project matrix if stacks are profiled, global risks, gates)
  ---8<--- ROADMAP MARKDOWN END
  ```
- Then, for each planned artifact, output one or more write blocks (examples):
  ```
  [[WRITE-FILE]]: docs/stack/<project>/overview.md
  ---8<--- START
  # <Project> – Overview
  ...
  ---8<--- END

  [[WRITE-FILE]]: docs/stack/<project>/<stack>.md
  ---8<--- START
  # <Project> – <Stack> Tech Stack
  ...
  ---8<--- END
  ```
- Do NOT write files; emit blocks only.
EOF

  read -r -d '' compliance <<'EOF'
COMPLIANCE:
- Future coder agents MUST satisfy linters/type-checkers **without simplifying functionality**; placeholders forbidden.
- Maximize reuse of existing code in later phases; reference modules/classes/functions explicitly.
HARD STOP:
- Confirm that no files were modified and only planning text was produced.
EOF

  read -r -d '' BLOCK_PROFILE <<EOF
PROFILE & PROJECT TYPE:
- PROFILE: ${PROFILE}
- PROJECT_KIND: ${PROJECT_KIND}
- STACK_HINTS: $(csv_or_empty "${STACK_HINTS}")
- QUALITY_LEVEL: ${QUALITY_LEVEL}
- LOCALE: ${LOCALE}
- If PROFILE=auto or PROJECT_KIND=auto, infer using Serena (if available) and heuristics (package.json, pyproject.toml, go.mod, pom.xml, Cargo.toml, docker/helm/terraform).
- Use hints only as bias; do not contradict symbol evidence.
EOF

  read -r -d '' BLOCK_SCHEMA <<EOF
ROADMAP SCHEMA: ${ROADMAP_SCHEMA}
- Emit a YAML front-matter with: id (stable slug), objective, phase, profile, project_kind, inferred_stacks, tags, schema, generated_at (ISO), locale.
- Title: ${TITLE_OVERRIDE:-<auto>}
- Required base sections (Schema v1):
  1) State Snapshot  2) Objectives & Acceptance  3) Task DAG
  4) Design/Constraints (profile-adaptive)  5) Test Strategy
  6) Tooling & Enforcement  7) Risks & Mitigations
  8) Gate/Exit Criteria  9) Open Questions (≤5)
- Sections to include (allow-list if provided): $(csv_or_empty "${SECTIONS}")
EOF

  read -r -d '' BLOCK_ADAPTIVITY <<EOF
ADAPTIVITY:
- If PROFILE=auto, propose the best-fit profile and **explain why** (symbols/paths).
- If PROJECT_KIND=auto, classify: monorepo/service/library/tooling/infra/data.
- List detected stacks per project (frontend/backend/infra/data/mobile/library) and cite evidence.
- When conflicting signals exist, prefer Serena symbol evidence over heuristics; ask up to 3 clarifying questions.
EOF

  # Assemble
  prompt="${guards}
${context}
${phaserules}
"

# Add standardized, adaptive controls (profile, schema, adaptivity)
  prompt+="${BLOCK_PROFILE}
${BLOCK_SCHEMA}
${BLOCK_ADAPTIVITY}
"

  if [[ "${USE_SERENA}" = "1" ]]; then
    prompt+="${serena}
"
  fi
  prompt+="${subagents}
${concurrency}
${enforce}
${deliverables}
"

  if [[ "${SAVE_STYLE}" = "multi" ]]; then
    prompt+="${savemulti}
"
  else
    prompt+="${saveindex}
"
  fi

  prompt+="${compliance}
"

  # Inject vars
  prompt="${prompt//<<<OBJECTIVE>>>/${OBJECTIVE}}"
  prompt="${prompt//<<<PHASE>>>/${PHASE}}"
  prompt="${prompt//<<<GIT_HISTORY>>>/${GIT_HISTORY}}"
  prompt="${prompt//<<<ROADMAP_PATH>>>/${ROADMAP_PATH}}"
  prompt="${prompt//<<<INDEX_SAVE_PATH>>>/${INDEX_SAVE_PATH}}"
  prompt="${prompt//<<<DATE_STR>>>/${DATE_STR}}"

  printf '%s' "$prompt"
}

### ===== Queen flag autodetect (alpha robust) =====
detect_queen_flag() {
  local flag=""
  if npx claude-flow@alpha hive-mind spawn --help 2>/dev/null | grep -qi -- '--queen-type'; then
    if npx claude-flow@alpha hive-mind spawn --help 2>/dev/null | grep -qi 'adaptive'; then
      flag="--queen-type adaptive"
    elif npx claude-flow@alpha hive-mind spawn --help 2>/dev/null | grep -qi 'strategic'; then
      flag="--queen-type strategic"
    fi
  fi
  printf '%s' "$flag"
}

### ===== Planning action =====
do_plan() {
  if [[ "${USE_SERENA}" = "1" && "${SERENA_REQUIRED}" = "1" ]]; then
    echo "[WARN] USE_SERENA=1 & SERENA_REQUIRED=1: ensure Serena MCP is configured in Claude Code for this project." >&2
  fi

  local prompt queen_flag
  prompt="$(build_prompt)"
  queen_flag="$(detect_queen_flag)"
  npx claude-flow@alpha hive-mind spawn \
    "${prompt}" \
    --claude --agents "${AGENTS}" --verbose --auto-scale --auto-spawn \
    --memory-namespace "${MEM_NAMESPACE}" \
    ${queen_flag}
}

### ===== Persistence utilities =====
extract_save_at() {
  grep -Eo '^\[\[SAVE-AT\]\]:[[:space:]]+.*$' | sed -E 's/^\[\[SAVE-AT\]\]:[[:space:]]+//'
}
extract_index_body() {
  awk '/---8<--- ROADMAP MARKDOWN START/{flag=1; next} /---8<--- ROADMAP MARKDOWN END/{flag=0} flag'
}
iterate_write_blocks() {
  # Emits NUL-separated pairs: path \0 content \0 ...
  awk '
    /^\[\[WRITE-FILE\]\]:/ { file=$0; sub(/^\[\[WRITE-FILE\]\]:[[:space:]]+/,"",file); inblock=0; next }
    /---8<--- START/ { inblock=1; content=""; next }
    /---8<--- END/ {
      if (file != "") {
        printf "%s\0%s\0", file, content
        file=""; content="";
      }
      inblock=0; next
    }
    { if (inblock==1) content = content $0 "\n" }
  '
}

write_index_block() {
  local save_at="$1"; shift
  local body="$1"; shift
  if [[ -z "${save_at}" ]]; then
    echo "[INFO] No [[SAVE-AT]] index block detected." >&2
    return 0
  fi
  mkdir -p "$(dirname "${save_at}")"
  if [[ "${DRY_RUN}" = "1" ]]; then
    printf 'DRY-RUN: would write INDEX → %s (bytes=%d)\n' "${save_at}" "$(printf '%s' "${body}" | wc -c)"
  else
    printf '%s' "${body}" > "${save_at}"
    printf 'WROTE INDEX: %s\n' "${save_at}"
  fi
}

write_file_blocks() {
  local tmp="$1"
  # Read NUL-separated pairs from iterate_write_blocks
  python3 - "$tmp" "$DRY_RUN" <<'PY'
import os, sys
path = sys.argv[1]
dry = sys.argv[2] == "1"
data = sys.stdin.buffer.read().decode('utf-8', 'replace')
parts = [p for p in data.split("\0") if p != ""]
for i in range(0, len(parts), 2):
    target = parts[i].strip()
    content = parts[i+1]
    os.makedirs(os.path.dirname(target) or ".", exist_ok=True)
    if dry:
        print(f"DRY-RUN: would write FILE → {target} (bytes={len(content.encode())})")
    else:
        with open(target, "w", encoding="utf-8") as f:
            f.write(content)
        print(f"WROTE FILE: {target}")
PY
}

### ===== Persist/check action =====
do_persist_or_check() {
  local src="${ROADMAP_SRC:-}"
  local plan_dir="/plan_dir/_plan_blocks.$$"

  # Get input into temp file (from file or stdin)
  if [[ -n "${src}" ]]; then
    cat "${src}" > "${plan_dir}"
  else
    cat - > "${plan_dir}"
  fi

  # INDEX block
  local save_at body
  save_at="$(extract_save_at < "${plan_dir}" | head -n1 || true)"
  body="$(extract_index_body < "${plan_dir}" || true)"
  write_index_block "${save_at}" "${body}"

  # [[WRITE-FILE]] blocks
  iterate_write_blocks < "${plan_dir}" | write_file_blocks "${plan_dir}"

  rm -f "${plan_dir}"
}

### ===== Main =====
case "${ACTION}" in
  plan)
    do_plan
    ;;
  persist|check)
    [[ "${ACTION}" = "check" ]] && DRY_RUN="1"
    do_persist_or_check
    ;;
  plan+persist)
    # Plan to temp file then persist it (keeps separation explicit).
    plan_dir="plan_dir/_plan_output.$$"
    # shellcheck disable=SC2094
    { do_plan; } | tee "${plan_dir}"
    ROADMAP_SRC="${plan_dir}" ACTION="persist" DRY_RUN="${DRY_RUN}" "$0"
    ;;
  *)
    echo "Unknown ACTION=${ACTION}. Use plan | persist | check | plan+persist" >&2
    exit 2
    ;;
esac
